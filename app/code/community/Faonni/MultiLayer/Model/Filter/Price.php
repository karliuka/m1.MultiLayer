<?php
/**
 * Faonni
 *  
 * NOTICE OF LICENSE
 *
 * This source file is subject to the Open Software License (OSL 3.0)
 * that is bundled with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://opensource.org/licenses/osl-3.0.php
 *
 *
 * DISCLAIMER
 *
 * Do not edit or add to this file if you wish to upgrade module to newer
 * versions in the future.
 * 
 * @package     Faonni_MultiLayer
 * @copyright   Copyright (c) 2015 Karliuka Vitalii(karliuka.vitalii@gmail.com) 
 * @license     http://opensource.org/licenses/osl-3.0.php  Open Software License (OSL 3.0)
 */
class Faonni_MultiLayer_Model_Filter_Price 
	extends Mage_Catalog_Model_Layer_Filter_Price
{
    /**
     * Retrieve resource instance
     *
     * @return Faonni_MultiLayer_Model_Resource_Filter_Price
     */
    protected function _getResource()
    {
        if (is_null($this->_resource)) {
            $this->_resource = Mage::getResourceModel('faonni_multilayer/filter_price');
        }
        return $this->_resource;
    }
	
    /**
     * Apply price range filter
     *
     * @param Zend_Controller_Request_Abstract $request
     * @param $filterBlock
     *
     * @return Mage_Catalog_Model_Layer_Filter_Price
     */
    public function apply(Zend_Controller_Request_Abstract $request, $filterBlock)
    {
        /**
         * Filter must be string: $fromPrice-$toPrice
         */
        $filter = $request->getParam($this->getRequestVar());
        if (!$filter) {
            return $this;
        }

        $filterParams = explode(',', $filter);
        $filter = $this->_validateFilter($filterParams[0]);
        if (!$filter) {
            return $this;
        }
		
        $this->setInterval($filter);
		list($from, $to) = $filter;
		
		$text = $this->_renderRangeLabel(empty($from) ? 0 : $from, $to);
		$filters = array($filterParams[0] => $text);
		$intervals = array();
		
        for ($i = 1; $i < count($filterParams); ++$i) {
            $filter = $this->_validateFilter($filterParams[$i]);
            if ($filter) {
                list($from, $to) = $filter;
				$filters[$filterParams[$i]] = $this->_renderRangeLabel(empty($from) ? 0 : $from, $to);
				$intervals[] = $filter;
            }
        }		
		
		$selected = (0 < count($filters)) ? array_keys($filters) : array();
		$this->setSelected($selected);	
		$this->setIntervals($intervals);	
		
        $this->_applyPriceRange();
        $this->getLayer()->getState()->addFilter($this->_createItem($filters, $selected));

        return $this;
    }
	
    /**
     * Create filter item object
     *
     * @param   mixed $options
     * @param   mixed $value
     * @param   int $count
     * @return  Mage_Catalog_Model_Layer_Filter_Item
     */
    protected function _createItem($options, $value, $count=0)
    {
		$filter = Mage::getModel('faonni_multilayer/filter_item')
            ->setFilter($this)
            ->setLabel($options)
            ->setValue($value)
            ->setCount($count);
		
		if (is_array($options)) {
			$items = array();
			foreach ($options as $optionId => $label) {
				$items[] = $this->_createItem($label, $optionId, $count);
			}
			$filter->setItems($items);
		}			
		return $filter;
    }
	
    /**
     * Get data for build price filter items
     *
     * @return array
     */
    protected function _getItemsData()
    {
        if (Mage::app()->getStore()->getConfig(self::XML_PATH_RANGE_CALCULATION) == self::RANGE_CALCULATION_IMPROVED) {
			return $this->_getCalculatedItemsData();
        }
		
        $collection = $this->getLayer()->getProductCollection();
		$fullParts = $parts = $collection->getSelect()->getPart(Zend_Db_Select::WHERE);

		foreach ($parts as $alias => $condition) {
			if (false !== strpos($condition, 'price_index')) {
				unset($parts[$alias]);
			}
		}
		$collection->getSelect()->setPart(Zend_Db_Select::WHERE, $parts);			
		
        $range = $this->getPriceRange();
        $dbRanges = $this->getRangeItemCounts($range);
        $data = array();

        if (!empty($dbRanges)) {
            $lastIndex = array_keys($dbRanges);
            $lastIndex = $lastIndex[count($lastIndex) - 1];

            foreach ($dbRanges as $index => $count) {
                $fromPrice = ($index == 1) ? '' : (($index - 1) * $range);
                $toPrice = ($index == $lastIndex) ? '' : ($index * $range);

                $data[] = array(
                    'label' => $this->_renderRangeLabel($fromPrice, $toPrice),
                    'value' => $fromPrice . '-' . $toPrice,
                    'count' => $count,
                );
            }
        }

		$collection->getSelect()->setPart(Zend_Db_Select::WHERE, $fullParts);
		
        return $data;
    }
	
    /**
     * Get data generated by algorithm for build price filter items
     *
     * @return array
     */
    protected function _getCalculatedItemsData()
    {
        /** @var $algorithmModel Mage_Catalog_Model_Layer_Filter_Price_Algorithm */
        $algorithmModel = Mage::getSingleton('catalog/layer_filter_price_algorithm');
		
        $collection = $this->getLayer()->getProductCollection();
		$fullParts = $parts = $collection->getSelect()->getPart(Zend_Db_Select::WHERE);

		foreach ($parts as $alias => $condition) {
			if (false !== strpos($condition, 'price_index')) {
				unset($parts[$alias]);
			}
		}
		$collection->getSelect()->setPart(Zend_Db_Select::WHERE, $parts);	

        $algorithmModel->setPricesModel($this)->setStatistics(
            $collection->getMinPrice(),
            $collection->getMaxPrice(),
            $collection->getPriceStandardDeviation(),
            $collection->getPricesCount()
        );

        $items = array();
        foreach ($algorithmModel->calculateSeparators() as $separator) {
            $items[] = array(
                'label' => $this->_renderRangeLabel($separator['from'], $separator['to']),
                'value' => (($separator['from'] == 0) ? '' : $separator['from']) . '-' . $separator['to'],
                'count' => $separator['count'],
            );
        }

		$collection->getSelect()->setPart(Zend_Db_Select::WHERE, $fullParts);
		
        return $items;
    }	
}